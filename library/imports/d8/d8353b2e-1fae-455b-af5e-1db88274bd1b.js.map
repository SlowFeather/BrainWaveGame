{"version":3,"sources":["assets\\scripts\\UI\\GameUI\\RadarChart.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["const {ccclass, property} = cc._decorator;\n\n@ccclass\nexport default class RadarChart extends cc.Component {\n\n    @property({\n        type: Number,\n        tooltip:\"数据个数\"\n    })\n    pointNumber:number=8;\n    @property({\n        type: Number,\n        tooltip:\"线宽度\"\n    })\n    lineWidth:number=1;\n    @property({\n        type: cc.Color,\n        tooltip:\"线颜色\"\n    })\n    lineColor:cc.Color = new cc.Color(0,0,0,255);\n    @property({\n        type: cc.Color,\n        tooltip:\"内部颜色\"\n    })\n    backgroundColor:cc.Color = new cc.Color(0,0,0,255);\n\n    //数据数组\n    @property([Number])\n    DataArray:number[]=[];\n\n    /**\n     * 渲染组件\n     *\n     * @type {cc.Graphics}\n     * @memberof RadarChart\n     */\n     graphics: cc.Graphics = null;\n     /**\n      * 点数组\n      *\n      * @memberof RadarChart\n      */\n     nodes = [];\n\n    onLoad () {\n        //拿到组件\n        this.graphics=this.node.getComponent(cc.Graphics);\n    }\n\n    start () {\n        //创建贝塞尔点\n        this.CreateBezierNodes();\n    }\n\n    update (dt) {\n        this.UpdateColorCycle();\n        this.UpdateNodePos();\n        this.Render();\n    }\n\n    /**\n     * 创建点\n     *\n     * @memberof RadarChart\n     */\n    CreateBezierNodes () {\n        //创建8个顶点\n        for(var quantity = 0, len = this.pointNumber; quantity < len; quantity++) {\n            var theta = Math.PI * 2 * quantity / len;\n            var x = 0;\n            var y = 0;\n            this.nodes.push({\n                x: x,\n                y: y,\n                angle: theta,\n                //angle: Math.random() * Math.PI * 2,\n                //弧度\n                theta: theta\n            });\n        }\n    }\n\n    /**\n     * 更新颜色周期\n     *\n     * @memberof RadarChart\n     */\n    UpdateColorCycle() {\n        this.graphics.strokeColor=this.lineColor;\n        this.graphics.fillColor=this.backgroundColor;\n        this.node.opacity=this.graphics.fillColor.a;\n    }\n    /**\n     * 更新点位\n     *\n     * @memberof RadarChart\n     */\n    UpdateNodePos(){\n        let nodes = this.nodes;\n        for (let index = 0; index < nodes.length; index++) {\n            let node = nodes[index];\n            node.x = this.DataArray[index]*Math.cos(node.theta);\n            node.y= this.DataArray[index]*Math.sin(node.theta);\n        }\n    }\n\n    /**\n     * 渲染\n     *\n     * @memberof RadarChart\n     */\n    Render() {\n        let nodes = this.nodes;\n        let graphics = this.graphics;\n        let color = this.lineColor;\n        let backgroundColor=this.backgroundColor;\n        var currentIndex, nextIndex, xc, yc;\n        \n        graphics.clear();\n        //下面有多少个点遍历多少次                \n        [].forEach.call(nodes, (node, index) => {\n    \n            currentIndex = nodes[nodes.length - 1];\n            //第0个node\n            nextIndex = nodes[0];\n            \n            xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.5;\n            yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.5;\n            \n            graphics.strokeColor = color;\n            graphics.fillColor = backgroundColor;\n            graphics.lineWidth =this.lineWidth;\n\n            graphics.moveTo(xc, yc);\n            \n            // Draw through N points\n            for(var N = 0; N < nodes.length; N++) {\n                \n                currentIndex = nodes[N];\n                nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.5;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.5;\n            \n                graphics.quadraticCurveTo(currentIndex.x, currentIndex.y, xc, yc);\n            }\n             \n            graphics.fill();\n            graphics.stroke();\n                        \n\n            //#region 渲染贝塞尔手柄\n            // graphics.lineWidth = 1;\n            // graphics.lineCap = cc.Graphics.LineCap.ROUND;\n            // graphics.lineJoin = cc.Graphics.LineJoin.ROUND;\n            // graphics.strokeColor.fromHEX('#a9a9a9');\n            // graphics.fillColor.fromHEX('#a9a9a9');\n            // Draw through N points\n            // for(var N = 0; N < nodes.length; N++) {\n                \n            //     // First anchor\n            //     currentIndex = nodes[N];\n            //     nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n            //     xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.8;\n            //     yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.8;\n                \n            //     graphics.moveTo(xc, yc);\n                \n            //     // Second anchor\n            //     currentIndex = nextIndex;\n            //     nextIndex = N + 2 > nodes.length - 1 ? nodes[N - nodes.length + 2] : nodes[N + 2]; \n                \n            //     xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.2;\n            //     yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.2;\n                \n            //     graphics.lineTo(xc, yc);\n            //     graphics.stroke();\n                \n            //     // First anchor\n            //     currentIndex = nodes[N];\n            //     nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n            //     xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.8;\n            //     yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.8;\n                \n            //     graphics.circle(xc, yc, 2);\n            //     graphics.fill();\n            \n            //     // Second anchor\n            //     currentIndex = nextIndex;\n            //     nextIndex = N + 2 > nodes.length - 1 ? nodes[N - nodes.length + 2] : nodes[N + 2]; \n                \n            //     xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.2;\n            //     yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.2;\n                \n            //     graphics.circle(xc, yc, 2);\n            //     graphics.fill();\n                \n            // }\n            //#endregion\n\n        })\n    }\n    \n}\n"]}